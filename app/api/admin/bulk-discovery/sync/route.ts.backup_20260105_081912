import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// ============================================
// BATCH SIZE - Change this to adjust parallel sync count
// Recommended: 10 for normal, 20-50 for fast, 5 for slow connections
// ============================================
const BATCH_SIZE = 10;

// Fetch timeout in milliseconds (30 seconds)
const FETCH_TIMEOUT = 60000;  // 60 seconds for search

// Fetch with timeout wrapper
async function fetchWithTimeout(url: string, options: RequestInit, timeout: number = FETCH_TIMEOUT): Promise<Response> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    return response;
  } catch (error: any) {
    clearTimeout(timeoutId);
    if (error.name === 'AbortError') {
      throw new Error('Request timeout');
    }
    throw error;
  }
}

// Update hierarchy counts after sync
async function updateHierarchyCounts(municipalityId: string, areaId: string | null) {
  // Update community counts
  const { data: communities } = await supabase
    .from('communities')
    .select('id')
    .eq('municipality_id', municipalityId);

  for (const comm of communities || []) {
    const { data: commBuildings } = await supabase
      .from('discovered_buildings')
      .select('status')
      .eq('community_id', comm.id);
    
    const discovered = commBuildings?.length || 0;
    const synced = commBuildings?.filter(b => b.status === 'synced').length || 0;

    await supabase
      .from('communities')
      .update({
        buildings_discovered: discovered,
        buildings_synced: synced
      })
      .eq('id', comm.id);
  }

  // Update municipality count
  const { data: muniBuildings } = await supabase
    .from('discovered_buildings')
    .select('status')
    .eq('municipality_id', municipalityId);

  await supabase
    .from('municipalities')
    .update({
      buildings_discovered: muniBuildings?.length || 0,
      buildings_synced: muniBuildings?.filter(b => b.status === 'synced').length || 0
    })
    .eq('id', municipalityId);

  // Update area count
  if (areaId) {
    const { data: areaBuildings } = await supabase
      .from('discovered_buildings')
      .select('status')
      .eq('area_id', areaId);

    await supabase
      .from('treb_areas')
      .update({
        buildings_discovered: areaBuildings?.length || 0,
        buildings_synced: areaBuildings?.filter(b => b.status === 'synced').length || 0
      })
      .eq('id', areaId);
  }
}

export async function POST(request: NextRequest) {
  try {
    const { buildingIds } = await request.json();

    if (!buildingIds || !Array.isArray(buildingIds) || buildingIds.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Building IDs array is required' },
        { status: 400 }
      );
    }

    // Fetch building details
    const { data: buildings, error: fetchError } = await supabase
      .from('discovered_buildings')
      .select('*')
      .in('id', buildingIds);

    if (fetchError) throw fetchError;

    if (!buildings || buildings.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No buildings found' },
        { status: 404 }
      );
    }

    // Create a streaming response
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      async start(controller) {
        const sendProgress = (data: any) => {
          controller.enqueue(encoder.encode(`data:${JSON.stringify(data)}\n\n`));
        };

        let completed = 0;
        let failed = 0;
        const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';

        console.log(`Starting sync of ${buildings.length} buildings with batch size ${BATCH_SIZE}`);

        // Process in batches
        for (let i = 0; i < buildings.length; i += BATCH_SIZE) {
          const batch = buildings.slice(i, i + BATCH_SIZE);
          console.log(`Processing batch ${Math.floor(i/BATCH_SIZE) + 1}: buildings ${i+1}-${Math.min(i+BATCH_SIZE, buildings.length)}`);

          // Process batch in parallel
          const promises = batch.map(async (building) => {
            try {
              // Update status to syncing
              await supabase
                .from('discovered_buildings')
                .update({ status: 'syncing' })
                .eq('id', building.id);

              sendProgress({
                type: 'progress',
                buildingId: building.id,
                buildingName: building.building_name || `${building.street_number} ${building.street_name}`,
                status: 'syncing',
                progress: { current: i + batch.indexOf(building) + 1, total: buildings.length, completed, failed }
              });

              // Step 1: Search PropTx
              const searchResponse = await fetchWithTimeout(
                `${baseUrl}/api/admin/buildings/search`,
                {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    streetNumber: building.street_number,
                    streetName: building.street_name,
                    city: building.city,
                    buildingName: building.building_name || `${building.street_number} ${building.street_name}`,
                    fullData: true
                  })
                }
              );

              if (!searchResponse.ok) {
                throw new Error(`Search failed: ${searchResponse.status}`);
              }

              const searchData = await searchResponse.json();

              if (!searchData.success || !searchData.allListings || searchData.allListings.length === 0) {
                throw new Error('No listings found');
              }

              // Step 2: Save to database
              const saveResponse = await fetchWithTimeout(
                `${baseUrl}/api/admin/buildings/save`,
                {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    buildingData: {
                      buildingName: building.building_name || searchData.building?.buildingName,
                      streetNumber: building.street_number,
                      streetName: building.street_name,
                      city: building.city,
                      slug: searchData.building?.slug,
                      canonicalAddress: searchData.building?.canonicalAddress
                    },
                    listingsChunk: searchData.allListings,
                    chunkIndex: 0,
                    totalChunks: 1
                  })
                },
                180000 // 180 seconds (3 min) for large buildings (larger buildings)
              );

              if (!saveResponse.ok) {
                throw new Error(`Save failed: ${saveResponse.status}`);
              }

              const saveData = await saveResponse.json();

              // Update discovered_building status
              await supabase
                .from('discovered_buildings')
                .update({
                  status: 'synced',
                  building_id: saveData.building?.id || null,
                  synced_at: new Date().toISOString(),
                  retry_count: 0,
                  failed_reason: null
                })
                .eq('id', building.id);

              completed++;

              sendProgress({
                type: 'progress',
                buildingId: building.id,
                buildingName: building.building_name || `${building.street_number} ${building.street_name}`,
                status: 'synced',
                listingCount: searchData.allListings.length,
                progress: { current: i + batch.indexOf(building) + 1, total: buildings.length, completed, failed }
              });

              console.log(` Synced: ${building.building_name || building.street_number + ' ' + building.street_name}`);
              return { success: true, buildingId: building.id };

            } catch (error: any) {
              console.error(` Failed: ${building.building_name || building.id}:`, error.message);

              const currentRetry = building.retry_count || 0;

              await supabase
                .from('discovered_buildings')
                .update({
                  status: 'failed',
                  retry_count: currentRetry + 1,
                  failed_reason: error.message
                })
                .eq('id', building.id);

              failed++;

              sendProgress({
                type: 'progress',
                buildingId: building.id,
                buildingName: building.building_name || `${building.street_number} ${building.street_name}`,
                status: 'failed',
                error: error.message,
                progress: { current: i + batch.indexOf(building) + 1, total: buildings.length, completed, failed }
              });

              return { success: false, buildingId: building.id, error: error.message };
            }
          });

          // Wait for batch to complete
          await Promise.all(promises);
        }

        // Update hierarchy counts
        const firstBuilding = buildings[0];
        if (firstBuilding.municipality_id) {
          await updateHierarchyCounts(firstBuilding.municipality_id, firstBuilding.area_id);
        }

        // Send completion
        sendProgress({
          type: 'complete',
          summary: {
            total: buildings.length,
            completed,
            failed
          }
        });

        console.log(`Sync complete: ${completed} succeeded, ${failed} failed`);
        controller.close();
      }
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive'
      }
    });

  } catch (error: any) {
    console.error('Sync error:', error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}

