import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function POST(request: NextRequest) {
  try {
    const { communityId, communityName, municipalityId, municipalityName } = await request.json();

    if (!municipalityId || !municipalityName) {
      return NextResponse.json(
        { success: false, error: 'Municipality is required' },
        { status: 400 }
      );
    }

    // Get area info for this municipality
    const { data: muniData } = await supabase
      .from('municipalities')
      .select('area_id, treb_areas(id, name)')
      .eq('id', municipalityId)
      .single();

    const areaId = muniData?.area_id;

    // Query PropTx for condo apartments
    const baseUrl = process.env.PROPTX_RESO_API_URL;
    const token = process.env.PROPTX_DLA_TOKEN || process.env.PROPTX_VOW_TOKEN || process.env.PROPTX_BEARER_TOKEN;

    if (!baseUrl || !token) {
      return NextResponse.json(
        { success: false, error: 'PropTx configuration missing' },
        { status: 500 }
      );
    }

    // Build filter based on municipality and optionally community
    let filter = `City eq '${municipalityName}' and PropertySubType eq 'Condo Apartment'`;
    if (communityName) {
      filter += ` and CityRegion eq '${communityName}'`;
    }

    const select = 'StreetNumber,StreetName,StreetSuffix,City,CityRegion,BuildingName,ListingKey';
    const url = `${baseUrl}Property?$filter=${encodeURIComponent(filter)}&$select=${select}&$top=10000`;

    console.log('Discovering buildings:', { municipalityName, communityName });

    const response = await fetch(url, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`PropTx API error: ${response.status}`);
    }

    const data = await response.json();
    const listings = data.value || [];

    console.log(`Found ${listings.length} listings`);

    // Group listings by address to get unique buildings
    const buildingMap = new Map<string, any>();

    for (const listing of listings) {
      if (!listing.StreetNumber || !listing.StreetName) continue;

      const key = `${listing.StreetNumber}|${listing.StreetName}|${listing.City}`.toLowerCase();
      
      if (!buildingMap.has(key)) {
        buildingMap.set(key, {
          street_number: listing.StreetNumber,
          street_name: listing.StreetName,
          street_suffix: listing.StreetSuffix || null,
          city: listing.City,
          building_name: listing.BuildingName || null,
          proptx_community: listing.CityRegion || null,
          listing_count: 0,
          listings: []
        });
      }

      const building = buildingMap.get(key);
      building.listing_count++;
      
      // Use most common building name
      if (listing.BuildingName && !building.building_name) {
        building.building_name = listing.BuildingName;
      }
    }

    console.log(`Grouped into ${buildingMap.size} unique buildings`);

    // Check which buildings already exist in our database
    const { data: existingBuildings } = await supabase
      .from('buildings')
      .select('street_number, street_name, city')
      .or(
        Array.from(buildingMap.values())
          .map(b => `and(street_number.eq.${b.street_number},street_name.ilike.${b.street_name}%,city.ilike.${b.city}%)`)
          .join(',')
      );

    const existingSet = new Set(
      (existingBuildings || []).map(b => 
        `${b.street_number}|${b.street_name}|${b.city}`.toLowerCase()
      )
    );

    // Upsert buildings into discovered_buildings table
    const buildingsToUpsert = [];

    for (const [key, building] of buildingMap) {
      // Check if already synced (exists in buildings table)
      const isSynced = existingSet.has(key);

      // Find or get community_id if we have community name
      let resolvedCommunityId = communityId;
      if (!resolvedCommunityId && building.proptx_community) {
        const { data: comm } = await supabase
          .from('communities')
          .select('id')
          .eq('name', building.proptx_community)
          .eq('municipality_id', municipalityId)
          .single();
        resolvedCommunityId = comm?.id || null;
      }

      buildingsToUpsert.push({
        area_id: areaId,
        municipality_id: municipalityId,
        community_id: resolvedCommunityId,
        street_number: building.street_number,
        street_name: building.street_name,
        street_suffix: building.street_suffix,
        city: building.city,
        building_name: building.building_name,
        building_name_original: building.building_name,
        proptx_area: (muniData?.treb_areas as any)?.name || null,
        proptx_municipality: municipalityName,
        proptx_community: building.proptx_community,
        listing_count: building.listing_count,
        status: isSynced ? 'synced' : 'pending',
        discovered_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      });
    }

    // Upsert in batches
    const batchSize = 100;
    for (let i = 0; i < buildingsToUpsert.length; i += batchSize) {
      const batch = buildingsToUpsert.slice(i, i + batchSize);
      
      const { error: upsertError } = await supabase
        .from('discovered_buildings')
        .upsert(batch, {
          onConflict: 'street_number,street_name,city',
          ignoreDuplicates: false
        });

      if (upsertError) {
        console.error('Upsert error:', upsertError);
      }
    }

    // Update discovery status on community/municipality
    const pendingCount = buildingsToUpsert.filter(b => b.status === 'pending').length;
    const syncedCount = buildingsToUpsert.filter(b => b.status === 'synced').length;

    if (communityId) {
      await supabase
        .from('communities')
        .update({
          discovery_status: syncedCount === buildingsToUpsert.length ? 'synced' : 'discovered',
          buildings_discovered: buildingsToUpsert.length,
          buildings_synced: syncedCount,
          last_discovery_at: new Date().toISOString()
        })
        .eq('id', communityId);
    }

    await supabase
      .from('municipalities')
      .update({
        discovery_status: 'discovered',
        buildings_discovered: buildingsToUpsert.length,
        buildings_synced: syncedCount,
        last_discovery_at: new Date().toISOString()
      })
      .eq('id', municipalityId);

    // Fetch the saved buildings to return
    let query = supabase
      .from('discovered_buildings')
      .select('*')
      .eq('municipality_id', municipalityId)
      .order('building_name', { ascending: true });

    if (communityId) {
      query = query.eq('community_id', communityId);
    }

    const { data: savedBuildings, error: fetchError } = await query;

    if (fetchError) throw fetchError;

    return NextResponse.json({
      success: true,
      buildings: savedBuildings || [],
      summary: {
        total: buildingsToUpsert.length,
        pending: pendingCount,
        synced: syncedCount
      }
    });

  } catch (error: any) {
    console.error('Discovery error:', error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
