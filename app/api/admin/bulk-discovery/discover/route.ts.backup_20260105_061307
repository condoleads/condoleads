import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Extract first meaningful word from street name for grouping
function getStreetKey(streetName: string): string {
  if (!streetName) return '';
  
  let s = streetName.toLowerCase().trim();
  s = s.replace(/\(.*?\)/g, '');
  s = s.replace(/unit\s*\d*.*/i, '');
  s = s.replace(/\s*furnished.*/i, '');
  s = s.replace(/\s*furn$/i, '');
  s = s.replace(/\./g, ' ');
  s = s.replace(/\s+/g, ' ').trim();
  
  const skipWords = ['st', 'e', 'w', 'n', 's'];
  const words = s.split(' ');
  
  for (const word of words) {
    if (skipWords.includes(word)) continue;
    if (word.length >= 3) return word;
  }
  
  const cleaned = s.replace(/\s+/g, '');
  return cleaned.length >= 3 ? cleaned : '';
}

// Paginate through ALL results - no limits
async function fetchAllListings(
  baseUrl: string, 
  filter: string, 
  select: string, 
  headers: any
): Promise<any[]> {
  const allResults: any[] = [];
  let skip = 0;
  const pageSize = 5000;
  
  while (true) {
    const url = `${baseUrl}Property?$filter=${encodeURIComponent(filter)}&$select=${select}&$top=${pageSize}&$skip=${skip}`;
    
    try {
      const resp = await fetch(url, { headers });
      if (!resp.ok) break;
      
      const data = await resp.json();
      const results = data.value || [];
      
      if (results.length === 0) break;
      
      allResults.push(...results);
      
      if (results.length < pageSize) break;
      skip += pageSize;
    } catch (error) {
      console.error(`Fetch error at skip=${skip}:`, error);
      break;
    }
  }
  
  return allResults;
}

// Search for building name for a specific address
async function findBuildingName(
  baseUrl: string, 
  headers: any, 
  streetNumber: string, 
  streetKey: string,
  city: string
): Promise<string | null> {
  const cityPrefix = city.split(' ')[0];
  const filter = `StreetNumber eq '${streetNumber}' and contains(tolower(StreetName),'${streetKey}') and contains(City,'${cityPrefix}')`;
  const url = `${baseUrl}Property?$filter=${encodeURIComponent(filter)}&$select=BuildingName&$top=500`;
  
  try {
    const resp = await fetch(url, { headers });
    if (!resp.ok) return null;
    
    const data = await resp.json();
    const listings = data.value || [];
    
    const nameCounts = new Map<string, number>();
    for (const listing of listings) {
      if (listing.BuildingName && listing.BuildingName.trim()) {
        const name = listing.BuildingName.trim();
        nameCounts.set(name, (nameCounts.get(name) || 0) + 1);
      }
    }
    
    let bestName: string | null = null;
    let maxCount = 0;
    for (const [name, count] of nameCounts) {
      if (count > maxCount) {
        maxCount = count;
        bestName = name;
      }
    }
    
    return bestName;
  } catch (error) {
    console.error(`Error finding name for ${streetNumber} ${streetKey}:`, error);
    return null;
  }
}

export async function POST(request: NextRequest) {
  try {
    const { communityId, communityName, municipalityId, municipalityName } = await request.json();

    if (!municipalityId || !municipalityName) {
      return NextResponse.json(
        { success: false, error: 'Municipality is required' },
        { status: 400 }
      );
    }

    const { data: muniData } = await supabase
      .from('municipalities')
      .select('area_id, treb_areas(id, name)')
      .eq('id', municipalityId)
      .single();

    const areaId = muniData?.area_id;

    const baseUrl = process.env.PROPTX_RESO_API_URL;
    const token = process.env.PROPTX_VOW_TOKEN || process.env.PROPTX_DLA_TOKEN || process.env.PROPTX_BEARER_TOKEN;

    if (!baseUrl || !token) {
      return NextResponse.json(
        { success: false, error: 'PropTx configuration missing' },
        { status: 500 }
      );
    }

    let baseFilter = `City eq '${municipalityName}' and PropertySubType eq 'Condo Apartment'`;
    if (communityName) {
      baseFilter += ` and CityRegion eq '${communityName}'`;
    }

    const select = 'StreetNumber,StreetName,StreetSuffix,City,CityRegion,BuildingName';
    const headers = {
      'Authorization': `Bearer ${token}`,
      'Accept': 'application/json'
    };

    console.log('Discovering buildings:', { municipalityName, communityName });

    // STEP 1: Fetch ALL listings (paginated, no limit)
    const allListings: any[] = [];

    // Active (no status filter = default)
    console.log('Fetching Active listings...');
    const activeListings = await fetchAllListings(baseUrl, baseFilter, select, headers);
    allListings.push(...activeListings);
    console.log(`Active: ${activeListings.length}`);

    // Sold
    console.log('Fetching Sold listings...');
    const soldFilter = `${baseFilter} and (StandardStatus eq 'Closed' or MlsStatus eq 'Sold' or MlsStatus eq 'Sld')`;
    const soldListings = await fetchAllListings(baseUrl, soldFilter, select, headers);
    allListings.push(...soldListings);
    console.log(`Sold: ${soldListings.length}`);

    // Leased
    console.log('Fetching Leased listings...');
    const leasedFilter = `${baseFilter} and (MlsStatus eq 'Leased' or MlsStatus eq 'Lsd')`;
    const leasedListings = await fetchAllListings(baseUrl, leasedFilter, select, headers);
    allListings.push(...leasedListings);
    console.log(`Leased: ${leasedListings.length}`);

    console.log(`Total listings: ${allListings.length}`);

    // STEP 2: Group by street number + first word
    const buildingMap = new Map<string, any>();

    for (const listing of allListings) {
      if (!listing.StreetNumber || !listing.StreetName) continue;

      const streetKey = getStreetKey(listing.StreetName);
      if (!streetKey || streetKey.length < 3) continue;

      const key = `${listing.StreetNumber}|${streetKey}`.toLowerCase();
      
      if (!buildingMap.has(key)) {
        buildingMap.set(key, {
          street_number: listing.StreetNumber,
          street_name: listing.StreetName,
          street_suffix: listing.StreetSuffix || null,
          street_key: streetKey,
          city: listing.City,
          proptx_community: listing.CityRegion || null,
          names: new Map<string, number>(),
          listing_count: 0
        });
      }

      const building = buildingMap.get(key)!;
      building.listing_count++;
      
      if (listing.BuildingName && listing.BuildingName.trim()) {
        const name = listing.BuildingName.trim();
        building.names.set(name, (building.names.get(name) || 0) + 1);
      }
    }

    console.log(`Grouped into ${buildingMap.size} unique buildings`);

    // STEP 3: For buildings WITHOUT names, do targeted search
    const buildingsWithoutNames = Array.from(buildingMap.entries()).filter(([_, b]) => b.names.size === 0);
    console.log(`Buildings without names: ${buildingsWithoutNames.length} - searching...`);

    let namesFoundCount = 0;
    for (const [key, building] of buildingsWithoutNames) {
      const foundName = await findBuildingName(
        baseUrl, 
        headers, 
        building.street_number, 
        building.street_key,
        building.city
      );
      
      if (foundName) {
        building.names.set(foundName, 1);
        namesFoundCount++;
        console.log(`  Found: ${building.street_number} ${building.street_key} -> '${foundName}'`);
      }
    }

    console.log(`Found names for ${namesFoundCount} additional buildings`);

    // Load existing discovered buildings
    let existingQuery = supabase
      .from('discovered_buildings')
      .select('id, street_number, street_key, status, building_id, building_name')
      .eq('municipality_id', municipalityId);

    if (communityId) {
      existingQuery = existingQuery.eq('community_id', communityId);
    }

    const { data: existingBuildings } = await existingQuery;

    const existingMap = new Map<string, any>();
    for (const eb of existingBuildings || []) {
      const key = `${eb.street_number}|${eb.street_key}`.toLowerCase();
      existingMap.set(key, eb);
    }

    // Check synced buildings
    const { data: syncedBuildings } = await supabase
      .from('buildings')
      .select('street_number, street_name, city');

    const syncedSet = new Set<string>();
    for (const sb of syncedBuildings || []) {
      const streetKey = getStreetKey(sb.street_name);
      const key = `${sb.street_number}|${streetKey}`.toLowerCase();
      syncedSet.add(key);
    }

    // Prepare upserts
    const buildingsToUpsert = [];

    for (const [key, building] of buildingMap) {
      let bestName: string | null = null;
      let maxCount = 0;
      for (const [name, count] of building.names) {
        if (count > maxCount) {
          maxCount = count;
          bestName = name;
        }
      }

      const existing = existingMap.get(key);
      const isSynced = syncedSet.has(key) || existing?.status === 'synced';

      // Keep manual edits to building_name
      const finalName = existing?.building_name || bestName;

      buildingsToUpsert.push({
        area_id: areaId,
        municipality_id: municipalityId,
        community_id: communityId || null,
        street_number: building.street_number,
        street_name: building.street_name,
        street_suffix: building.street_suffix,
        street_key: building.street_key,
        city: building.city,
        building_name: finalName,
        building_name_original: bestName,
        proptx_area: (muniData?.treb_areas as any)?.name || null,
        proptx_municipality: municipalityName,
        proptx_community: building.proptx_community,
        listing_count: building.listing_count,
        status: isSynced ? 'synced' : (existing?.status || 'pending'),
        building_id: existing?.building_id || null,
        discovered_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      });
    }

    // Upsert in batches
    const batchSize = 100;
    for (let i = 0; i < buildingsToUpsert.length; i += batchSize) {
      const batch = buildingsToUpsert.slice(i, i + batchSize);
      
      const { error: upsertError } = await supabase
        .from('discovered_buildings')
        .upsert(batch, {
          onConflict: 'street_number,street_key,municipality_id',
          ignoreDuplicates: false
        });

      if (upsertError) {
        console.error('Upsert error:', upsertError);
      }
    }

    // Update counts
    const pendingCount = buildingsToUpsert.filter(b => b.status === 'pending').length;
    const syncedCount = buildingsToUpsert.filter(b => b.status === 'synced').length;
    const withNamesCount = buildingsToUpsert.filter(b => b.building_name).length;
    const withoutNamesCount = buildingsToUpsert.length - withNamesCount;

    if (communityId) {
      await supabase
        .from('communities')
        .update({
          discovery_status: syncedCount === buildingsToUpsert.length ? 'complete' : 'discovered',
          buildings_discovered: buildingsToUpsert.length,
          buildings_synced: syncedCount,
          last_discovery_at: new Date().toISOString()
        })
        .eq('id', communityId);
    }

    await supabase
      .from('municipalities')
      .update({
        discovery_status: 'discovered',
        buildings_discovered: buildingsToUpsert.length,
        buildings_synced: syncedCount,
        last_discovery_at: new Date().toISOString()
      })
      .eq('id', municipalityId);

    // Fetch all
    let fetchQuery = supabase
      .from('discovered_buildings')
      .select('*')
      .eq('municipality_id', municipalityId)
      .order('building_name', { ascending: true, nullsFirst: false });

    if (communityId) {
      fetchQuery = fetchQuery.eq('community_id', communityId);
    }

    const { data: savedBuildings, error: fetchError } = await fetchQuery;

    if (fetchError) throw fetchError;

    // Final counts from saved data
    const finalWithNames = savedBuildings?.filter(b => b.building_name).length || 0;
    const finalWithoutNames = (savedBuildings?.length || 0) - finalWithNames;

    return NextResponse.json({
      success: true,
      buildings: savedBuildings || [],
      summary: {
        total: savedBuildings?.length || 0,
        withNames: finalWithNames,
        withoutNames: finalWithoutNames,
        pending: savedBuildings?.filter(b => b.status === 'pending').length || 0,
        synced: savedBuildings?.filter(b => b.status === 'synced').length || 0,
        failed: savedBuildings?.filter(b => b.status === 'failed').length || 0,
        listingsSearched: {
          active: activeListings.length,
          sold: soldListings.length,
          leased: leasedListings.length,
          total: allListings.length
        },
        namesFoundViaSearch: namesFoundCount
      }
    });

  } catch (error: any) {
    console.error('Discovery error:', error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
