// app/api/admin/market-analytics/calculate/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

const PROPTX_URL = process.env.PROPTX_RESO_API_URL || 'https://query.ampre.ca/odata/'
const PROPTX_TOKEN = process.env.PROPTX_DLA_TOKEN || process.env.PROPTX_VOW_TOKEN || process.env.PROPTX_BEARER_TOKEN

interface ParkingRecord {
  CountyOrParish: string
  City: string
  CityRegion: string
  ParkingMonthlyCost: number
}

// Fetch parking lease data from PropTx
async function fetchParkingLeaseData(maxRecords: number = 50000): Promise<ParkingRecord[]> {
  const found: ParkingRecord[] = []
  let skip = 0
  const batchSize = 500

  while (skip < maxRecords) {
    const filter = "PropertyType eq 'Residential Condo %26 Other' and (TransactionType eq 'For Lease' or StandardStatus eq 'Leased')"
    const select = "CountyOrParish,City,CityRegion,ParkingMonthlyCost"
    const url = `${PROPTX_URL}Property?$filter=${filter}&$select=${select}&$top=${batchSize}&$skip=${skip}`

    const response = await fetch(url, {
      headers: { 'Authorization': `Bearer ${PROPTX_TOKEN}` }
    })

    if (!response.ok) {
      console.error('PropTx API error:', response.status)
      break
    }

    const data = await response.json()
    if (!data.value || data.value.length === 0) break

    // Filter: has parking cost, Toronto no limit, outside Toronto max $250
    const filtered = data.value.filter((r: ParkingRecord) => {
      if (!r.ParkingMonthlyCost || r.ParkingMonthlyCost <= 0) return false
      if (r.CountyOrParish === 'Toronto') return true
      return r.ParkingMonthlyCost <= 250
    })

    found.push(...filtered)
    skip += batchSize

    // Stop early if no more records
    if (data.value.length < batchSize) break
  }

  return found
}

// Calculate averages by level
function calculateAverages(records: ParkingRecord[], minRecords: number = 10) {
  const byArea: Record<string, number[]> = {}
  const byMunicipality: Record<string, { area: string; values: number[] }> = {}
  const byCommunity: Record<string, { area: string; municipality: string; values: number[] }> = {}

  for (const r of records) {
    const area = r.CountyOrParish || 'Unknown'
    const municipality = r.City || 'Unknown'
    const community = r.CityRegion || 'Unknown'
    const value = r.ParkingMonthlyCost

    // By Area
    if (!byArea[area]) byArea[area] = []
    byArea[area].push(value)

    // By Municipality
    if (!byMunicipality[municipality]) byMunicipality[municipality] = { area, values: [] }
    byMunicipality[municipality].values.push(value)

    // By Community
    const communityKey = `${municipality}|${community}`
    if (!byCommunity[communityKey]) byCommunity[communityKey] = { area, municipality, values: [] }
    byCommunity[communityKey].values.push(value)
  }

  // Calculate averages (min records required)
  const areaAverages = Object.entries(byArea)
    .filter(([_, values]) => values.length >= minRecords)
    .map(([name, values]) => ({
      name,
      average: Math.round(values.reduce((a, b) => a + b, 0) / values.length * 100) / 100,
      count: values.length
    }))

  const municipalityAverages = Object.entries(byMunicipality)
    .filter(([_, data]) => data.values.length >= minRecords)
    .map(([name, data]) => ({
      name,
      area: data.area,
      average: Math.round(data.values.reduce((a, b) => a + b, 0) / data.values.length * 100) / 100,
      count: data.values.length
    }))

  const communityAverages = Object.entries(byCommunity)
    .filter(([_, data]) => data.values.length >= minRecords)
    .map(([key, data]) => ({
      name: key.split('|')[1],
      municipality: data.municipality,
      area: data.area,
      average: Math.round(data.values.reduce((a, b) => a + b, 0) / data.values.length * 100) / 100,
      count: data.values.length
    }))

  return { areaAverages, municipalityAverages, communityAverages }
}

// Save to database
async function saveAdjustments(
  type: 'parking_lease',
  areaAverages: any[],
  municipalityAverages: any[],
  communityAverages: any[]
) {
  const now = new Date().toISOString()
  const results = { areas: 0, municipalities: 0, communities: 0, errors: [] as string[] }

  // Save Area level
  for (const area of areaAverages) {
    const { data: areaRecord } = await supabase
      .from('treb_areas')
      .select('id')
      .eq('name', area.name)
      .single()

    if (areaRecord) {
      // Check if adjustment exists
      const { data: existing } = await supabase
        .from('adjustments')
        .select('id')
        .eq('area_id', areaRecord.id)
        .is('municipality_id', null)
        .is('community_id', null)
        .is('building_id', null)
        .single()

      const updateData = {
        parking_lease_calculated: area.average,
        parking_lease_count: area.count,
        parking_lease_calculated_at: now,
        updated_at: now
      }

      if (existing) {
        await supabase.from('adjustments').update(updateData).eq('id', existing.id)
      } else {
        await supabase.from('adjustments').insert({
          area_id: areaRecord.id,
          ...updateData,
          created_at: now
        })
      }
      results.areas++
    }
  }

  // Save Municipality level
  for (const muni of municipalityAverages) {
    const { data: muniRecord } = await supabase
      .from('municipalities')
      .select('id, area_id')
      .eq('name', muni.name)
      .single()

    if (muniRecord) {
      const { data: existing } = await supabase
        .from('adjustments')
        .select('id')
        .eq('municipality_id', muniRecord.id)
        .is('community_id', null)
        .is('building_id', null)
        .single()

      const updateData = {
        parking_lease_calculated: muni.average,
        parking_lease_count: muni.count,
        parking_lease_calculated_at: now,
        updated_at: now
      }

      if (existing) {
        await supabase.from('adjustments').update(updateData).eq('id', existing.id)
      } else {
        await supabase.from('adjustments').insert({
          area_id: muniRecord.area_id,
          municipality_id: muniRecord.id,
          ...updateData,
          created_at: now
        })
      }
      results.municipalities++
    }
  }

  // Save Community level
  for (const comm of communityAverages) {
    const { data: commRecord } = await supabase
      .from('communities')
      .select('id, municipality_id')
      .eq('name', comm.name)
      .single()

    if (commRecord) {
      const { data: muniRecord } = await supabase
        .from('municipalities')
        .select('area_id')
        .eq('id', commRecord.municipality_id)
        .single()

      const { data: existing } = await supabase
        .from('adjustments')
        .select('id')
        .eq('community_id', commRecord.id)
        .is('building_id', null)
        .single()

      const updateData = {
        parking_lease_calculated: comm.average,
        parking_lease_count: comm.count,
        parking_lease_calculated_at: now,
        updated_at: now
      }

      if (existing) {
        await supabase.from('adjustments').update(updateData).eq('id', existing.id)
      } else {
        await supabase.from('adjustments').insert({
          area_id: muniRecord?.area_id,
          municipality_id: commRecord.municipality_id,
          community_id: commRecord.id,
          ...updateData,
          created_at: now
        })
      }
      results.communities++
    }
  }

  return results
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { type = 'parking_lease', maxRecords = 50000, minRecords = 10 } = body

    if (type !== 'parking_lease') {
      return NextResponse.json({ success: false, error: 'Only parking_lease supported currently' }, { status: 400 })
    }

    // Step 1: Fetch data from PropTx
    const records = await fetchParkingLeaseData(maxRecords)

    // Step 2: Calculate averages
    const { areaAverages, municipalityAverages, communityAverages } = calculateAverages(records, minRecords)

    // Step 3: Save to database
    const saveResults = await saveAdjustments(type, areaAverages, municipalityAverages, communityAverages)

    return NextResponse.json({
      success: true,
      totalRecords: records.length,
      averages: {
        areas: areaAverages,
        municipalities: municipalityAverages,
        communities: communityAverages
      },
      saved: saveResults
    })

  } catch (error) {
    console.error('Calculate error:', error)
    return NextResponse.json({ success: false, error: String(error) }, { status: 500 })
  }
}

// GET - fetch current calculated values
export async function GET() {
  try {
    const { data, error } = await supabase
      .from('adjustments')
      .select(`
        *,
        treb_areas:area_id(name),
        municipalities:municipality_id(name, code),
        communities:community_id(name),
        buildings:building_id(building_name)
      `)
      .order('created_at', { ascending: false })

    if (error) throw error

    return NextResponse.json({ success: true, adjustments: data })
  } catch (error) {
    console.error('Fetch error:', error)
    return NextResponse.json({ success: false, error: String(error) }, { status: 500 })
  }
}
