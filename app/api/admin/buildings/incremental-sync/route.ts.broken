import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { EnhancedPropTxClient } from '@/lib/proptx/enhanced-client';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function GET() {
  return NextResponse.json({
    status: 'ready',
    message: 'Incremental sync API ready',
    timestamp: new Date().toISOString()
  });
}

export async function POST(request: NextRequest) {
  try {
    const { buildingId, forceFullSync } = await request.json();
    
    console.log(' Starting incremental sync...');
    console.log('Request params:', { buildingId, forceFullSync });
    
    let results;
    if (buildingId && buildingId !== 'all') {
      // Handle specific building - could be ID or slug
      if (buildingId === 'x2-condos') {
        // Handle the test building by slug
        results = await syncBuildingBySlug('x2-condos-101-charles-st-e-toronto', forceFullSync);
      } else {
        // Handle by actual building ID
        results = await syncSingleBuilding(buildingId, forceFullSync);
      }
    } else {
      // Sync all buildings
      results = await syncAllBuildings();
    }
    
    return NextResponse.json({
      success: true,
      ...results,
      message: 'Incremental sync completed successfully'
    });
    
  } catch (error: any) {
    console.error('? Incremental sync failed:', error);
    return NextResponse.json(
      { 
        error: 'Incremental sync failed',
        details: error.message,
        stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
      },
      { status: 500 }
    );
  }
}

async function syncBuildingBySlug(slug: string, forceFullSync = false) {
  console.log(` Finding building by slug: ${slug}`);
  
  // Find building by slug
  const { data: building, error: buildingError } = await supabase
    .from('buildings')
    .select('*')
    .eq('slug', slug)
    .single();
  
  if (buildingError || !building) {
    throw new Error(`Building not found with slug: ${slug}. Please make sure the building exists in the database first by running a complete sync.`);
  }
  
  console.log(` Found building: ${building.building_name} (ID: ${building.id})`);
  
  return await syncSingleBuilding(building.id, forceFullSync);
}

async function syncAllBuildings() {
  console.log(' Syncing all buildings...');
  
  // Get all buildings that need sync
  const { data: buildings, error } = await supabase
    .from('buildings')
    .select('id, building_name, street_number, street_name, canonical_address, last_sync_at, sync_status')
    .in('sync_status', ['completed', 'active'])
    .order('last_sync_at', { ascending: true });
  
  if (error) throw error;
  
  if (!buildings || buildings.length === 0) {
    return {
      buildingsProcessed: 0,
      totalChanges: 0,
      message: 'No buildings found in database. Please add buildings first using complete sync.'
    };
  }
  
  const syncResults = [];
  let totalChanges = 0;
  
  for (const building of buildings) {
    try {
      const result = await syncSingleBuilding(building.id, false);
      syncResults.push({
        building_id: building.id,
        building_name: building.building_name,
        ...result
      });
      totalChanges += result.totalChanges || 0;
      
      // Small delay between buildings
      await new Promise(resolve => setTimeout(resolve, 1000));
      
    } catch (error: any) {
      console.error(`Failed to sync building ${building.building_name}:`, error);
      syncResults.push({
        building_id: building.id,
        building_name: building.building_name,
        error: error.message
      });
    }
  }
  
  return {
    buildingsProcessed: buildings.length,
    totalChanges,
    syncResults
  };
}

async function syncSingleBuilding(buildingId: string, forceFullSync = false) {
  console.log(` Syncing building ${buildingId}...`);
  
  // Get building details
  const { data: building, error: buildingError } = await supabase
    .from('buildings')
    .select('*')
    .eq('id', buildingId)
    .single();
  
  if (buildingError) throw buildingError;
  
  // Get last sync time
  const lastSyncDate = building.last_sync_at 
    ? new Date(building.last_sync_at) 
    : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days ago if never synced
  
  console.log(`Last sync: ${lastSyncDate.toISOString()}`);
  
  // Build search address
  const searchAddress = building.canonical_address || 
    `${building.street_number} ${building.street_name}`;
  
  console.log(` Searching PropTx for: ${searchAddress}`);
  
  // Search PropTx for current listings using incremental sync method
  const proptxClient = new EnhancedPropTxClient();
  const currentResults = await proptxClient.searchForIncrementalSync(searchAddress);
  
  console.log(` PropTx returned ${currentResults.total} listings`);
  
  // Get existing listings from database
  const { data: existingListings } = await supabase
    .from('mls_listings')
    .select('id, listing_key, list_price, standard_status, close_price, updated_at')
    .eq('building_id', buildingId);
  
  console.log(` Database has ${existingListings?.length || 0} existing listings`);
  
  // Perform incremental analysis
  const changes = await analyzeChanges(
    currentResults.allResults || [],
    existingListings || [],
    lastSyncDate,
    forceFullSync
  );
  
  // Apply changes
  const updateResults = await applyChanges(buildingId, changes);
  
  // Update building sync timestamp
  await supabase
    .from('buildings')
    .update({ 
      last_sync_at: new Date().toISOString(),
      sync_status: 'completed'
    })
    .eq('id', buildingId);
  
  // Record sync history
  await recordIncrementalSyncHistory(buildingId, changes, updateResults);
  
  return {
    buildingName: building.building_name || building.canonical_address,
    lastSyncDate: lastSyncDate.toISOString(),
    currentListingsFound: currentResults.total,
    existingListingsCount: existingListings?.length || 0,
    changes,
    updateResults,
    totalChanges: changes.newListings.length + changes.updatedListings.length + changes.removedListings.length
  };
}

async function analyzeChanges(currentListings: any[], existingListings: any[], lastSyncDate: Date, forceFullSync: boolean) {
  console.log(' Analyzing changes...');
  
  const existingByMLS = new Map();
  existingListings.forEach(listing => {
    if (listing.listing_key) {
      existingByMLS.set(listing.listing_key, listing);
    }
  });
  
  const currentByMLS = new Map();
  currentListings.forEach(listing => {
    if (listing.ListingKey) {
      currentByMLS.set(listing.ListingKey, listing);
    }
  });
  
  const changes = {
    newListings: [],
    updatedListings: [],
    removedListings: [],
    unchangedListings: []
  };
  
  // Find new and updated listings
  for (const currentListing of currentListings) {
    const mlsKey = currentListing.ListingKey;
    if (!mlsKey) continue;
    
    const existing = existingByMLS.get(mlsKey);
    
    if (!existing) {
      // New listing
      changes.newListings.push({
        type: 'new',
        listing: currentListing,
        reason: 'Not in database'
      });
    } else {
      // Check if listing was modified
      const shouldUpdate = forceFullSync || 
        isListingModified(currentListing, existing, lastSyncDate);
      
      if (shouldUpdate) {
        changes.updatedListings.push({
          type: 'updated',
          listing: currentListing,
          existing: existing,
          reason: getUpdateReason(currentListing, existing)
        });
      } else {
        changes.unchangedListings.push(existing);
      }
    }
  }
  
    // Find removed listings
  for (const [mlsKey, existing] of existingByMLS) {
    if (!currentByMLS.has(mlsKey)) {
      changes.removedListings.push({
        type: 'removed',
        existing: existing,
        reason: 'No longer in PropTx results'
      });
    }
  }
  }
  
  console.log(` Changes: ${changes.newListings.length} new, ${changes.updatedListings.length} updated, ${changes.removedListings.length} removed, ${changes.unchangedListings.length} unchanged`);
  
  return changes;
}

function isListingModified(currentListing: any, existingListing: any, lastSyncDate: Date): boolean {
  // Check modification timestamp
  if (currentListing.ModificationTimestamp) {
    const modDate = new Date(currentListing.ModificationTimestamp);
    if (modDate > lastSyncDate) {
      return true;
    }
  }
  
  // Check price changes
  const currentPrice = parseInt(currentListing.ListPrice) || 0;
  const existingPrice = existingListing.list_price || 0;
  if (currentPrice !== existingPrice) {
    return true;
  }
  
  // Check status changes
  if (currentListing.StandardStatus !== existingListing.standard_status) {
    return true;
  }
  
  // Check close price for sold/leased
  const currentClosePrice = parseInt(currentListing.ClosePrice) || 0;
  const existingClosePrice = existingListing.close_price || 0;
  if (currentClosePrice !== existingClosePrice) {
    return true;
  }
  
  return false;
}

function getUpdateReason(currentListing: any, existingListing: any): string {
  const reasons = [];
  
  const currentPrice = parseInt(currentListing.ListPrice) || 0;
  const existingPrice = existingListing.list_price || 0;
  if (currentPrice !== existingPrice) {
    reasons.push(`Price: ${existingPrice}  ${currentPrice}`);
  }
  
  if (currentListing.StandardStatus !== existingListing.standard_status) {
    reasons.push(`Status: ${existingListing.standard_status}  ${currentListing.StandardStatus}`);
  }
  
  const currentClosePrice = parseInt(currentListing.ClosePrice) || 0;
  const existingClosePrice = existingListing.close_price || 0;
  if (currentClosePrice !== existingClosePrice) {
    reasons.push(`Close Price: ${existingClosePrice}  ${currentClosePrice}`);
  }
  
  if (currentListing.ModificationTimestamp) {
    reasons.push(`Modified: ${currentListing.ModificationTimestamp}`);
  }
  
  return reasons.length > 0 ? reasons.join(', ') : 'Modified since last sync';
}

async function applyChanges(buildingId: string, changes: any) {
  console.log(' Applying changes...');
  
  const results = {
    newListingsAdded: 0,
    listingsUpdated: 0,
    listingsRemoved: 0,
    errors: []
  };
  
  // Add new listings (simplified for incremental sync)
  for (const change of changes.newListings) {
    try {
      const listingRecord = mapListingToDatabase(change.listing, buildingId);
      
      const { error } = await supabase
        .from('mls_listings')
        .insert(listingRecord);
      
      if (error) throw error;
      
      results.newListingsAdded++;
      
    } catch (error: any) {
      console.error(`Failed to add new listing ${change.listing.ListingKey}:`, error);
      results.errors.push(`New listing ${change.listing.ListingKey}: ${error.message}`);
    }
  }
  
  // Update existing listings
  for (const change of changes.updatedListings) {
    try {
      const listingRecord = mapListingToDatabase(change.listing, buildingId);
      delete listingRecord.created_at; // Don't update created timestamp
      listingRecord.updated_at = new Date().toISOString();
      
      const { error } = await supabase
        .from('mls_listings')
        .update(listingRecord)
        .eq('id', change.existing.id);
      
      if (error) throw error;
      
      results.listingsUpdated++;
      
    } catch (error: any) {
      console.error(`Failed to update listing ${change.listing.ListingKey}:`, error);
      results.errors.push(`Update listing ${change.listing.ListingKey}: ${error.message}`);
    }
  }
  
  // Mark removed listings as inactive
  for (const change of changes.removedListings) {
    try {
      await supabase
        .from('mls_listings')
        .update({
          standard_status: 'Removed',
          mls_status: 'Expired',
          updated_at: new Date().toISOString()
        })
        .eq('id', change.existing.id);
      
      results.listingsRemoved++;
      
    } catch (error: any) {
      console.error(`Failed to remove listing ${change.existing.listing_key}:`, error);
      results.errors.push(`Remove listing ${change.existing.listing_key}: ${error.message}`);
    }
  }
  
  return results;
}

function mapListingToDatabase(listing: any, buildingId: string) {
  // Basic mapping for incremental sync (essential fields only)
  return {
    building_id: buildingId,
    listing_key: listing.ListingKey || null,
    listing_id: listing.ListingId || null,
    street_number: listing.StreetNumber || null,
    street_name: listing.StreetName || null,
    unparsed_address: listing.UnparsedAddress || null,
    unit_number: listing.UnitNumber || listing.ApartmentNumber || null,
    property_type: listing.PropertyType || null,
    property_subtype: listing.PropertySubType || null,
    transaction_type: listing.TransactionType || null,
    list_price: parseInteger(listing.ListPrice),
    close_price: parseInteger(listing.ClosePrice),
    standard_status: listing.StandardStatus || null,
    mls_status: listing.MlsStatus || null,
    close_date: parseDate(listing.CloseDate),
    on_market_date: parseDate(listing.OnMarketDate),
    bedrooms_total: parseInteger(listing.BedroomsTotal),
    bathrooms_total_integer: parseDecimal(listing.BathroomsTotalInteger),
    building_area_total: parseInteger(listing.BuildingAreaTotal),
    association_fee: parseDecimal(listing.AssociationFee),
    parking_total: parseInteger(listing.ParkingTotal),
    locker: listing.Locker || null,
    balcony_type: listing.BalconyType || null,
    exposure: listing.Exposure || null,
    public_remarks: listing.PublicRemarks || null,
    public_remarks_extras: listing.PublicRemarksExtras || null,
    modification_timestamp: parseTimestamp(listing.ModificationTimestamp),
    price_change_timestamp: parseTimestamp(listing.PriceChangeTimestamp),
    available_in_idx: listing.StandardStatus === 'Active',
    available_in_vow: true,
    available_in_dla: true,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    last_synced_at: new Date().toISOString(),
    sync_source: 'dla_incremental'
  };
}

async function recordIncrementalSyncHistory(buildingId: string, changes: any, results: any) {
  await supabase.from('sync_history').insert({
    building_id: buildingId,
    feed_type: 'dla_incremental',
    listings_found: changes.newListings.length + changes.updatedListings.length + changes.unchangedListings.length,
    listings_created: results.newListingsAdded,
    listings_updated: results.listingsUpdated,
    sync_status: results.errors.length > 0 ? 'partial' : 'success',
    error_message: results.errors.length > 0 ? results.errors.join('; ') : null,
    started_at: new Date().toISOString(),
    completed_at: new Date().toISOString(),
    created_at: new Date().toISOString()
  });
}

// Helper functions
function parseInteger(value: any): number | null {
  if (value === null || value === undefined || value === '') return null;
  const parsed = parseInt(value.toString());
  return isNaN(parsed) ? null : parsed;
}

function parseDecimal(value: any): number | null {
  if (value === null || value === undefined || value === '') return null;
  const parsed = parseFloat(value.toString());
  return isNaN(parsed) ? null : parsed;
}

function parseDate(value: any): string | null {
  if (!value) return null;
  try {
    const date = new Date(value);
    return isNaN(date.getTime()) ? null : date.toISOString().split('T')[0];
  } catch {
    return null;
  }
}

function parseTimestamp(value: any): string | null {
  if (!value) return null;
  try {
    const date = new Date(value);
    return isNaN(date.getTime()) ? null : date.toISOString();
  } catch {
    return null;
  }
}







