'use server'
import { createClient } from '@/lib/supabase/server'
import { getOrCreateLead } from '@/lib/actions/leads'
import { trackActivity } from '@/lib/actions/user-activity'
import { headers } from 'next/headers'

interface CreateLeadFromRegistrationParams {
  userId: string
  fullName: string
  email: string
  phone?: string
  registrationSource: string
  registrationUrl?: string
  buildingId?: string
  buildingName?: string
  buildingAddress?: string
  listingId?: string
  listingAddress?: string
  unitNumber?: string
  message?: string
  estimatedValueMin?: number
  estimatedValueMax?: number
  propertyDetails?: any
}

export async function createLeadFromRegistration(params: CreateLeadFromRegistrationParams) {
  try {
    const supabase = createClient()
    
    // Get host from request headers
    const headersList = headers()
    const host = headersList.get('host') || ''
    
    console.log('üîç Lead creation - Host detected:', host)

    // Find agent by subdomain OR custom domain
    const agentId = await resolveAgentFromHost(supabase, host)
    
    console.log(`‚úÖ Lead assigned to agent: ${agentId}`)

    // Enhanced source mapping with specific action types
    const sourceMap: Record<string, string> = {
      'home_page': 'registration',
      'listing_card': 'property_inquiry',
      'estimator': 'estimator',
      'building_page': 'contact_form',
      'contact_form': 'contact_form',
      'message_agent': 'contact_form',
      'sale_offer': 'sale_evaluation_request',
      'building_visit': 'building_visit_request',
      'property_inquiry': 'property_inquiry'
    }

    const leadSource = sourceMap[params.registrationSource] || 'registration'

    // Extract building from URL if not provided
    let finalBuildingId = params.buildingId
    let finalBuildingName = params.buildingName
    let finalBuildingAddress = params.buildingAddress
    
    if (!finalBuildingId && params.registrationUrl) {
      const buildingInfo = await extractBuildingFromUrl(supabase, params.registrationUrl)
      if (buildingInfo) {
        finalBuildingId = buildingInfo.id || undefined
        if (!finalBuildingName) finalBuildingName = buildingInfo.building_name
        if (!finalBuildingAddress) finalBuildingAddress = buildingInfo.canonical_address
        console.log('üìç Extracted building from URL:', buildingInfo.building_name)
      }
    }

    // If we have buildingId but missing name/address, fetch it
    if (finalBuildingId && (!finalBuildingName || !finalBuildingAddress)) {
      const { data: buildingData } = await supabase
        .from('buildings')
        .select('building_name, canonical_address')
        .eq('id', finalBuildingId)
        .single()
      if (buildingData) {
        if (!finalBuildingName) finalBuildingName = buildingData.building_name
        if (!finalBuildingAddress) finalBuildingAddress = buildingData.canonical_address
        console.log('üìç Fetched building info:', buildingData.building_name)
      }
    }

    // If we have listingId but no unitNumber, fetch it from the listing
    if (params.listingId && !params.unitNumber) {
      const { data: listingData } = await supabase
        .from('mls_listings')
        .select('unit_number')
        .eq('id', params.listingId)
        .single()
      if (listingData?.unit_number) {
        params.unitNumber = listingData.unit_number
        console.log('üìç Fetched unit number from listing:', listingData.unit_number)
      }
    }

    // Build source URL - DON'T double-concatenate!
    // params.registrationUrl is already the full URL from window.location.href
    const sourceUrl = params.registrationUrl || undefined

    // Determine if this should force create a new lead
    const formSubmissionSources = [
      'contact_form',
      'listing_card',
      'building_page',
      'message_agent',
      'sale_offer',
      'building_visit',
      'property_inquiry',
      'home_page'
    ]
    const shouldForceNewLead = formSubmissionSources.includes(params.registrationSource)

    if (shouldForceNewLead) {
      console.log('üìù Form submission/Registration detected - creating NEW lead')
    }

    // Use the createLead function which sends emails
    const result = await getOrCreateLead({
      agentId: agentId,
      contactName: params.fullName,
      contactEmail: params.email,
      contactPhone: params.phone,
      source: leadSource as any,
      sourceUrl: sourceUrl,
      buildingId: finalBuildingId,
      listingId: params.listingId,
      message: params.message || buildLeadMessage(params, finalBuildingName, finalBuildingAddress),
      estimatedValueMin: params.estimatedValueMin,
      estimatedValueMax: params.estimatedValueMax,
      propertyDetails: {
        ...(params.propertyDetails || {}),
        buildingName: finalBuildingName,
        buildingAddress: finalBuildingAddress,
        unitNumber: params.unitNumber
      },
      forceNew: shouldForceNewLead
    })

    if (!result.success) {
      console.error('‚ùå Error creating lead from registration')
      return { success: false, error: 'Failed to create lead' }
    }

    console.log('‚úÖ Lead created successfully with email notification:', result.lead?.id)

    // Track registration activity with building info
    if (result.lead?.id) {
      await trackActivity({
        contactEmail: params.email,
        agentId: agentId,
        activityType: 'registration',
        activityData: {
          buildingId: finalBuildingId,
          buildingName: finalBuildingName,
          buildingAddress: finalBuildingAddress,
          listingId: params.listingId,
          unitNumber: params.unitNumber,
          registrationSource: params.registrationSource
        }
      }).catch(err => console.error('Failed to track registration activity:', err))
    }

    return { success: true, leadId: result.lead?.id }

  } catch (error) {
    console.error('‚ùå Unexpected error creating lead:', error)
    return { success: false, error: 'Failed to create lead' }
  }
}

// Build descriptive message for the lead
function buildLeadMessage(
  params: CreateLeadFromRegistrationParams,
  buildingName?: string,
  buildingAddress?: string
): string {
  const parts = ['New user registration']
  if (buildingName) parts.push(`for ${buildingName}`)
  if (params.unitNumber) parts.push(`Unit ${params.unitNumber}`)
  if (buildingAddress) parts.push(`(${buildingAddress})`)
  parts.push(`via ${params.registrationSource}`)
  return parts.join(' ')
}

// Resolve agent from host - handles both subdomains AND custom domains
async function resolveAgentFromHost(supabase: any, host: string): Promise<string> {
  const DEFAULT_AGENT_ID = 'd5ab9f8b-5819-4363-806c-a414657e7763' // Mary Smith fallback
  
  // Handle localhost - return default
  if (host.includes('localhost')) {
    console.log('üè† Localhost detected - using default agent')
    return DEFAULT_AGENT_ID
  }

  const parts = host.split('.')
  
  // Check if it's a custom domain (not condoleads.ca or *.condoleads.ca)
  const isCondoleadsDomain = host.includes('condoleads.ca')
  
  if (!isCondoleadsDomain) {
    // Custom domain like yourcondorealtor.ca or www.yourcondorealtor.ca
    // Strip www. if present
    const cleanDomain = host.replace(/^www\./, '')
    console.log('üåê Custom domain detected:', cleanDomain)
    
    const { data: agent, error } = await supabase
      .from('agents')
      .select('id, full_name')
      .eq('custom_domain', cleanDomain)
      .eq('is_active', true)
      .single()
    
    if (agent) {
      console.log(`‚úÖ Found agent for custom domain ${cleanDomain}: ${agent.full_name} (${agent.id})`)
      return agent.id
    } else {
      console.warn(`‚ö†Ô∏è No agent found for custom domain: ${cleanDomain}`, error?.message)
      // Also try with www. just in case it's stored that way
      const { data: agentWww } = await supabase
        .from('agents')
        .select('id, full_name')
        .eq('custom_domain', `www.${cleanDomain}`)
        .eq('is_active', true)
        .single()
      
      if (agentWww) {
        console.log(`‚úÖ Found agent for www.${cleanDomain}: ${agentWww.full_name}`)
        return agentWww.id
      }
      
      return DEFAULT_AGENT_ID
    }
  }
  
  // condoleads.ca domain - check for subdomain
  // condoleads.ca or www.condoleads.ca = no subdomain
  if (parts.length === 2 || (parts.length === 3 && parts[0] === 'www')) {
    console.log('üè† Main condoleads.ca domain - using default agent')
    return DEFAULT_AGENT_ID
  }
  
  // subdomain.condoleads.ca
  if (parts.length >= 3) {
    const subdomain = parts[0]
    console.log('üîó Subdomain detected:', subdomain)
    
    const { data: agent, error } = await supabase
      .from('agents')
      .select('id, full_name')
      .eq('subdomain', subdomain)
      .eq('is_active', true)
      .single()
    
    if (agent) {
      console.log(`‚úÖ Found agent for subdomain ${subdomain}: ${agent.full_name} (${agent.id})`)
      return agent.id
    } else {
      console.warn(`‚ö†Ô∏è No agent found for subdomain: ${subdomain}`, error?.message)
      return DEFAULT_AGENT_ID
    }
  }
  
  return DEFAULT_AGENT_ID
}

// Extract building OR development info from URL with flexible slug matching
async function extractBuildingFromUrl(
  supabase: any, 
  registrationUrl: string
): Promise<{ id: string; building_name: string; canonical_address: string } | null> {
  try {
    // Parse URL to get pathname
    const url = new URL(registrationUrl, 'https://condoleads.ca')
    const pathSegments = url.pathname.split('/').filter(s => s)
    const slug = pathSegments[0] // First segment after domain
    
    if (!slug || ['estimator', 'dashboard', 'login', 'admin', 'property', 'team'].includes(slug)) {
      return null
    }
    
    console.log('üîç Looking up building/development by slug:', slug)
    
    // Try exact building match first
    const { data: exactBuildingMatch } = await supabase
      .from('buildings')
      .select('id, building_name, canonical_address')
      .eq('slug', slug)
      .single()
    
    if (exactBuildingMatch) {
      console.log('üìç Found exact building match:', exactBuildingMatch.building_name)
      return exactBuildingMatch
    }
    
    // Try exact development match
    const { data: exactDevMatch } = await supabase
      .from('developments')
      .select('id, name, slug')
      .eq('slug', slug)
      .single()
    
    if (exactDevMatch) {
      console.log('üìç Found development match:', exactDevMatch.name)
      
      // Get the first building in this development for the building_id
      const { data: devBuildings } = await supabase
        .from('buildings')
        .select('id, building_name, canonical_address')
        .eq('development_id', exactDevMatch.id)
        .limit(1)
        .single()
      
      if (devBuildings) {
        // Return building info but with development name for display
        return {
          id: devBuildings.id,
          building_name: exactDevMatch.name, // Use development name for display
          canonical_address: devBuildings.canonical_address
        }
      }
      
      // No buildings linked, return development info without building_id
      // We'll return null for id but the name will be captured in propertyDetails
      return {
        id: '', // No specific building
        building_name: exactDevMatch.name,
        canonical_address: ''
      }
    }
    
    // No exact match - try partial building match
    const slugParts = slug.split('-')
    
    // Try progressively shorter prefixes to find a match
    for (let i = Math.min(slugParts.length, 6); i >= 2; i--) {
      const partialSlug = slugParts.slice(0, i).join('-')
      
      // Check buildings
      const { data: partialBuildingMatches } = await supabase
        .from('buildings')
        .select('id, building_name, canonical_address, slug')
        .ilike('slug', `${partialSlug}%`)
        .limit(5)
      
      if (partialBuildingMatches && partialBuildingMatches.length > 0) {
        if (partialBuildingMatches.length === 1) {
          console.log(`üìç Found building via partial match (${partialSlug}):`, partialBuildingMatches[0].building_name)
          return partialBuildingMatches[0]
        }
        
        // Multiple matches - try to find the best one
        for (const building of partialBuildingMatches) {
          if (slug.includes(building.slug.split('-').slice(0, 4).join('-'))) {
            console.log(`üìç Found best building match:`, building.building_name)
            return building
          }
        }
        
        console.log(`üìç Using first partial building match:`, partialBuildingMatches[0].building_name)
        return partialBuildingMatches[0]
      }
      
      // Check developments with partial match
      const { data: partialDevMatches } = await supabase
        .from('developments')
        .select('id, name, slug')
        .ilike('slug', `${partialSlug}%`)
        .limit(3)
      
      if (partialDevMatches && partialDevMatches.length > 0) {
        const dev = partialDevMatches[0]
        console.log(`üìç Found development via partial match (${partialSlug}):`, dev.name)
        
        // Get first building in development
        const { data: devBuilding } = await supabase
          .from('buildings')
          .select('id, building_name, canonical_address')
          .eq('development_id', dev.id)
          .limit(1)
          .single()
        
        if (devBuilding) {
          return {
            id: devBuilding.id,
            building_name: dev.name,
            canonical_address: devBuilding.canonical_address
          }
        }
        
        return {
          id: '',
          building_name: dev.name,
          canonical_address: ''
        }
      }
    }
    
    console.log('‚ö†Ô∏è No building or development found for slug:', slug)
    return null
    
  } catch (error) {
    console.error('Error extracting building from URL:', error)
    return null
  }
}